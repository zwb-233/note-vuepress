import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as s,e as n,o as t,r as h}from"./app-De620kUC.js";const d={};function r(c,i){const l=h("Mermaid");return t(),a("div",null,[i[0]||(i[0]=s('<h1 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C</span></a></h1><h2 id="c语言编译流程" tabindex="-1"><a class="header-anchor" href="#c语言编译流程"><span>C语言编译流程</span></a></h2><ul><li>C语言编译主要经过四个过程 <ul><li>预处理(Preprocessing) <ul><li>处理以#开头的预处理指令，比如#include、#define、#ifdef等。</li><li>生成的文件后缀为.i</li></ul></li><li>编译(Compiling) <ul><li>将预处理后的文件转换成<strong>汇编语言</strong></li><li>生成的文件后缀为.s</li></ul></li><li>汇编(Assembling) <ul><li>将汇编语言代码转换成目标<strong>二进制</strong>文件</li><li>生成的文件后缀为.o</li></ul></li><li>链接(Linking) <ul><li>将多个目标文件及所需的库文件组合生成最终的可执行文件</li></ul></li></ul></li></ul>',3)),n(l,{id:"mermaid-78",code:"eJxLL0osyFDwCbLmUgAC52fT2p/s3qar+3JRy9MlLc8ntOnq2unlwESf75n2Yv1EkFAxTOjZxnagKEgoH6538r5nfUuBQk/71z/rXP5iYQ9EhgsAKKA4rQ=="}),i[1]||(i[1]=s(`<h2 id="gcc-g-编译器使用" tabindex="-1"><a class="header-anchor" href="#gcc-g-编译器使用"><span>gcc/g++编译器使用</span></a></h2><h3 id="可用选项" tabindex="-1"><a class="header-anchor" href="#可用选项"><span>可用选项</span></a></h3><ul><li>gcc/g++常用的一些功能选项: <ul><li>-E 只激活预处理,这个不生成文件,你需要<code>-o</code>把它重定向到一个输出文件里面</li><li>-S 编译到汇编语言不进行汇编和链接</li><li>-c 编译到目标代码</li><li>-o 结果输出到对应文件</li><li>-static 此选项对生成的文件采用静态链接</li><li>-g 生成调试信息。GNU 调试器可利用该信息,一般配合优化项<code>-o0</code>使用</li><li>-shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库</li><li>-w 不生成任何警告信息</li><li>-Wall 生成所有警告信息</li></ul></li></ul><blockquote><p>编译选项</p></blockquote><ul><li><code>-D</code>: 添加额外宏信息, 例如: -DDEBUG、-DTHREAD=8</li><li><code>-m64</code>: 指定编译为 64 位应用程序</li><li><code>-std=</code>: 指定编译标准，例如：-std=c++11、-std=c++14</li><li><code>-g</code>: 包含调试信息</li><li><code>-w</code>: 不显示警告</li><li><code>-O</code>: 优化等级，通常使用：-O3</li><li><code>-I</code>: 加在头文件路径前</li><li><code>fPIC</code>: (Position-Independent Code), 产生的没有绝对地址，全部使用相对地址，代码可以被加载到内存的任意位置，且可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的</li></ul><blockquote><p>链接选项</p></blockquote><ul><li><code>-l</code>: 加在库名前面</li><li><code>-L</code>: 加在库路径前面</li><li><code>-Wl,&lt;选项&gt;</code>: 将逗号分隔的 &lt;选项&gt; 传递给链接器</li><li><code>-rpath=</code>: &quot;运行&quot; 的时候，去找的目录。运行的时候，要找 .so 文件，会从这个选项里指定的地方去找</li><li>优化选项见<a href="https://blog.csdn.net/QQ576494799/article/details/129161271" target="_blank" rel="noopener noreferrer">gcc编译优化（O0、O1、O2、O3、Os）</a></li></ul><h3 id="可执行文件编译" tabindex="-1"><a class="header-anchor" href="#可执行文件编译"><span>可执行文件编译</span></a></h3><blockquote><p>gcc和g++的用法相同,此处列出的是gcc的编译流程</p></blockquote><ul><li><p>预处理：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -E</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件] -o [自定义输出文件名.i]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>编译成汇编语言(隐藏了预处理操作):</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -S</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>编译.o的object文件(二进制文件，可用于链接):</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件] [.c源文件] [...] (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">可选选项：-o</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [自定文件名])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>编译最终可执行文件</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件] [.c源文件] [...] (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">可选选项：-o</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [自定文件名])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="库文件编译" tabindex="-1"><a class="header-anchor" href="#库文件编译"><span>库文件编译</span></a></h3><ul><li>库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行</li><li>库文件有两种，静态库和动态库,区别是: <ul><li>静态库在程序的链接阶段被复制到了程序中,打开程序就会将库加载到内存</li><li>动态库在链接阶段没有被复制到程序中,而是程序在运行时由系统动态加载到内存中供程序调用</li></ul></li><li><strong>静态库</strong>(.a文件) <ul><li>优点 <ul><li>静态库被打包到应用程序中加载速度快。</li><li>发布程序无需提供静态库，移植方便。</li></ul></li><li>缺点 <ul><li>消耗系统资源，浪费内存，对于相同的库，由于该库写入在程序之中，因此在加载多个程序的过程中加载了多次次这个库。</li><li>更新、部署、发布麻烦。</li></ul></li></ul></li><li><strong>动态库的路径与依赖关系</strong><ul><li>动态库的路径：当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径</li><li>动态库的依赖关系：程序启动之后，动态库会被动态加载到内存中，通过<code>ldd(list dynamic dependencies)</code>命令检查动态库依赖关系</li></ul></li><li><strong>动态库</strong>(.so文件) <ul><li>优点 <ul><li>可以实现进程间资源共享,库同时间只会加载一次</li><li>更新、部署、发布简单</li><li>可以控制何时加载动态库</li></ul></li><li>缺点 <ul><li>加载速度比静态库慢</li><li>发布程序时需要提供依赖的动态库</li></ul></li></ul></li><li><code>Windows</code>环境下静态库名字是<code>.lib</code>，动态库名字是<code>.dll</code><ul><li>对于<code>Windows</code>而言，动态库还有对应的<code>.lib</code>文件需要在编译时引入，这个静态库用于帮助程序知道<code>.dll</code>中有哪些数据</li><li><code>.dll</code>库的链接，需要直接放入编译出的可执行文件同目录下，或使用<code>Windows</code>提供的动态链接函数，如果希望暴露符号也需要<code>__declspec(dllexport)</code>导出</li><li>如果使用<code>CLion</code>编译最终库文件请点击构建对应任务的按钮(不是运行任务)，并且要注意<code>CLion</code>中每个无关联的构建是分开的任务</li><li>如果使用<code>CLion</code>编译最终可执行文件需要添加<code>-static-libgcc -static-libstdc++</code>编译参数，不然无法双击运行(命令行编译不需要)</li></ul></li></ul><blockquote><p>静态库</p></blockquote><ul><li><p>编库(先转成.o文件，再编成lib[自定库名].a)</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件] [.c源文件] [...] (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">可选选项：-o</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [自定文件名])</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ar</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -r</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lib[自定库名].a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.o文件] [.o文件] [...]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>链接</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库的路径]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><blockquote><p>动态库</p></blockquote><ul><li><p>编库</p><ul><li><p>第一种做法， 先转成.o文件，再编成.so文件</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -fpic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件] [.c源文件] [...]</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -shared</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.o文件] [.o文件] [...] -o lib[库名].so</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>第二种做法，直接转成.so文件</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -fpic</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -shared</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [.c源文件] [.c源文件] [...] -o lib[库名].so</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p>链接</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">gcc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [main文件] -o [自定义输出可执行文件名] -l[库名] -L[库所在路径] -Wl,</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">-rpath</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">[库所在路径</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h2 id="奇怪的编译错误" tabindex="-1"><a class="header-anchor" href="#奇怪的编译错误"><span>奇怪的编译错误</span></a></h2><h3 id="代码编写类" tabindex="-1"><a class="header-anchor" href="#代码编写类"><span>代码编写类</span></a></h3><h4 id="未给函数声明添加-结尾" tabindex="-1"><a class="header-anchor" href="#未给函数声明添加-结尾"><span>未给函数声明添加;结尾</span></a></h4><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stdarg.h:40:27:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> error:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> storage</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> class</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> specified</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> for</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> parameter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ‘__gnuc_va_list’</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">   40</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">typedef</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> __builtin_va_list</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> __gnuc_va_list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,20))])}const p=e(d,[["render",r],["__file","c.html.vue"]]),g=JSON.parse('{"path":"/note/C/c.html","title":"C","lang":"zh-CN","frontmatter":{"description":"C C语言编译流程 C语言编译主要经过四个过程 预处理(Preprocessing) 处理以#开头的预处理指令，比如#include、#define、#ifdef等。 生成的文件后缀为.i 编译(Compiling) 将预处理后的文件转换成汇编语言 生成的文件后缀为.s 汇编(Assembling) 将汇编语言代码转换成目标二进制文件 生成的文件后缀为...","head":[["meta",{"property":"og:url","content":"https://zwb233.github.io/note-vuepress/note-vuepress/note/C/c.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"C"}],["meta",{"property":"og:description","content":"C C语言编译流程 C语言编译主要经过四个过程 预处理(Preprocessing) 处理以#开头的预处理指令，比如#include、#define、#ifdef等。 生成的文件后缀为.i 编译(Compiling) 将预处理后的文件转换成汇编语言 生成的文件后缀为.s 汇编(Assembling) 将汇编语言代码转换成目标二进制文件 生成的文件后缀为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"12a\\",\\"url\\":\\"/note-vuepress/intro.html\\"}]}"]]},"headers":[{"level":2,"title":"C语言编译流程","slug":"c语言编译流程","link":"#c语言编译流程","children":[]},{"level":2,"title":"gcc/g++编译器使用","slug":"gcc-g-编译器使用","link":"#gcc-g-编译器使用","children":[{"level":3,"title":"可用选项","slug":"可用选项","link":"#可用选项","children":[]},{"level":3,"title":"可执行文件编译","slug":"可执行文件编译","link":"#可执行文件编译","children":[]},{"level":3,"title":"库文件编译","slug":"库文件编译","link":"#库文件编译","children":[]}]},{"level":2,"title":"奇怪的编译错误","slug":"奇怪的编译错误","link":"#奇怪的编译错误","children":[{"level":3,"title":"代码编写类","slug":"代码编写类","link":"#代码编写类","children":[]}]}],"readingTime":{"minutes":5.27,"words":1581},"filePathRelative":"note/C/c.md","excerpt":"\\n<h2>C语言编译流程</h2>\\n<ul>\\n<li>C语言编译主要经过四个过程\\n<ul>\\n<li>预处理(Preprocessing)\\n<ul>\\n<li>处理以#开头的预处理指令，比如#include、#define、#ifdef等。</li>\\n<li>生成的文件后缀为.i</li>\\n</ul>\\n</li>\\n<li>编译(Compiling)\\n<ul>\\n<li>将预处理后的文件转换成<strong>汇编语言</strong></li>\\n<li>生成的文件后缀为.s</li>\\n</ul>\\n</li>\\n<li>汇编(Assembling)\\n<ul>\\n<li>将汇编语言代码转换成目标<strong>二进制</strong>文件</li>\\n<li>生成的文件后缀为.o</li>\\n</ul>\\n</li>\\n<li>链接(Linking)\\n<ul>\\n<li>将多个目标文件及所需的库文件组合生成最终的可执行文件</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{p as comp,g as data};
